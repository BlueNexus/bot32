#! /usr/bin/env escript

main(Args) ->
	case lists:foldl(fun(Arg, {S,P,T}) ->
		case Arg of
			"-s" ++ Server -> {Server, P, T};
			"-p" ++ Port -> {S, list_to_integer(Port), T};
			"-t" ++ Transport ->
				case Transport of
					"ssl" -> {S, P, ssl};
					"gen_tcp" -> {S, P, gen_tcp};
					X -> io:fwrite("Unsupported transport method ~s~n", [X]), {S, P, T}
				end
		end
		end, rconfig(), Args) of

		{none, _, _} -> io:fwrite("A server address is required.\n");
		{_, none, _} -> io:fwrite("A server port is required.\n");
		{S,P,T} -> connect(S,P,T)
	end.

rconfig() ->
	case file:consult("core_config.crl") of
		{ok, [{S,P,T}]} -> {S,P,T};
		_ -> {none, none, gen_tcp}
	end.

connect(Server, Port, Transport) ->
	case {find_erl("."), find_erl("./mod")} of
		{error,_} -> io:fwrite("Failed to find Erlang files in current dir!\n");
		{_,error} -> io:fwrite("Failed to find Erlang files in ./mod!\n");
		{Core,Mod} ->
			case compile_all_to(Core, ".", false) of
				false -> io:fwrite("Failed to compile some core files; check errors and correct before running!\n");
				N ->
					io:fwrite("Compiled all core files with ~b warnings.~n", [N]),
					X = compile_all_to(lists:map(fun(T) -> "./mod/" ++ T end, Mod), "./mod/bin", true),
					io:fwrite("Compiled module files with ~b errors and ~b warnings.~n", [X div 1000000, X rem 1000000]),
					io:fwrite("trying connect to ~s:~b~n", [Server, Port]),
					common:start_nospawn(Server, Transport, Port)
			end
	end.

compile_all_to(Files, Dir, IgnoreFail) ->
	lists:foldl(fun
			(_, false) when not IgnoreFail -> false;
			(Fname, N) ->
				case compile:file(Fname, [return_warnings, report_errors, report_warnings, {outdir, Dir}]) of
					{ok,_} -> N;
					{ok,_,Warn} -> N+length(Warn);
					error -> N + 1000000;
					{error,_,_} -> N + 1000000
				end
		end, 0, Files).

find_erl(Directory) ->
	case file:list_dir(Directory) of
		{ok, Files} -> find_erl(Files, []);
		_ -> error
	end.

find_erl([], Proc) -> Proc;
find_erl([F|Raw], Proc) ->
	case re:run(F, "(.*/)?([a-zA-Z0-9_]+).erl", [{capture, all_but_first, list}]) of
		{match, [_,File]} -> find_erl(Raw, [list_to_atom(File) | Proc]);
		{match, [File]} -> find_erl(Raw, [list_to_atom(File) | Proc]);
		nomatch -> find_erl(Raw, Proc)
	end.
